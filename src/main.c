
#include "main.h"
#include "stm32f4xx_hal.h"
#include "app_config.h"
#include "ssd1306_spi.h"
#include "tuner.h"
#include <stdio.h>
#include <math.h>

// ---- HAL handles (CubeMX will generate actual definitions) ----
extern ADC_HandleTypeDef hadc1;
extern DMA_HandleTypeDef hdma_adc1;
extern TIM_HandleTypeDef htim2;
extern SPI_HandleTypeDef hspi1;

// ---- DMA audio buffers ----
__attribute__((section(".dma_buffer"))) __attribute__((aligned(4)))
static uint16_t adc_dma_buf[FRAME_LEN*2]; // double-buffer (half/complete)

static volatile int g_half_ready = 0;
static volatile int g_full_ready = 0;

// Selection state
static volatile uint32_t last_btn_time_ms_tuning = 0;
static volatile uint32_t last_btn_time_ms_string = 0;
static volatile int g_sel_tuning = 0; // 0..NUM_TUNINGS-1
static volatile int g_sel_string = 0; // 0..5

// ---- Callbacks from HAL (ensure these names match CubeMX) ----
void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {
    if (hadc->Instance == ADC1) g_half_ready = 1;
}
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    if (hadc->Instance == ADC1) g_full_ready = 1;
}

// EXTI callbacks for buttons
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    uint32_t now = HAL_GetTick();
    if (GPIO_Pin == BTN_TUNING_Pin) {
        if ((now - last_btn_time_ms_tuning) > BTN_DEBOUNCE_MS) {
            last_btn_time_ms_tuning = now;
            g_sel_tuning = (g_sel_tuning + 1) % NUM_TUNINGS;
            g_sel_string = 0; // lowest string when tuning changes
        }
    } else if (GPIO_Pin == BTN_STRING_Pin) {
        if ((now - last_btn_time_ms_string) > BTN_DEBOUNCE_MS) {
            last_btn_time_ms_string = now;
            g_sel_string = (g_sel_string + 1) % 6;
        }
    }
}

static void adc_configure_channel_pb1(void) {
    // Explicitly configure ADC1 channel to PB1 / ADC_CHANNEL_9
    ADC_ChannelConfTypeDef sConfig = {0};
    sConfig.Channel = ADC1_INPUT_CHANNEL;   // ADC_CHANNEL_9
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_56CYCLES; // good for audio-band
    sConfig.Offset = 0;
#if defined(ADC_SINGLE_ENDED_SUPPORTED)
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.OffsetSignedSaturation = DISABLE;
#endif
    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
        while (1) { /* configuration failed: check CubeMX ADC setup */ }
    }
}

static void start_sampling(void) {
    adc_configure_channel_pb1(); // ensure PB1/IN9 is selected

    // Start timer -> ADC external trigger -> DMA circular
    HAL_TIM_Base_Start(&htim2);
    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_dma_buf, FRAME_LEN*2);
}

static void ui_draw_header(void) {
    char head[32];
    snprintf(head, sizeof(head), "%s", kTunings[g_sel_tuning].tuning_name);
    ssd1306_draw_text_5x7(0, 0, head);
    ssd1306_draw_text_5x7(90, 0, "STR:");
    ssd1306_draw_text_5x7(112, 0, kTunings[g_sel_tuning].strings[g_sel_string].name);
}

static void ui_draw_meas(float f_meas, float f_target) {
    char line1[32], line2[32];
    const char* sname = kTunings[g_sel_tuning].strings[g_sel_string].name;
    snprintf(line1, sizeof(line1), "%s  %.2f Hz", sname, f_target);
    snprintf(line2, sizeof(line2), "Meas: %.2f Hz", f_meas);
    ssd1306_draw_text_5x7(0, 12, line1);
    ssd1306_draw_text_5x7(0, 24, line2);

    float cents = 1200.0f * logf(f_meas / f_target) / logf(2.0f);
    if (cents > 50.0f) cents = 50.0f;
    if (cents < -50.0f) cents = -50.0f;
    char line3[32];
    snprintf(line3, sizeof(line3), "Cents: %+0.1f", cents);
    ssd1306_draw_text_5x7(0, 36, line3);

    int percent = (int)cents; // map ±50c to ±50%
    percent = (percent * 100) / 50;
    ssd1306_draw_bar_centered(50-10, UI_BAR_WIDTH, 10, percent);
}

static void ui_show_msg(const char* msg) {
    ssd1306_clear();
    ui_draw_header();
    ssd1306_draw_text_5x7(0, 12, msg);
    ssd1306_update();
}

// Convert DMA half (uint16 with mid-bias ~2048) to int16 centered around 0
static void convert_u12_to_i16(const uint16_t* in, int16_t* out, size_t n) {
    for (size_t i=0;i<n;i++) {
        int32_t v = (int32_t)in[i];
        v -= 2048;           // remove bias (assumes ADC 12-bit)
        v <<= 4;             // scale to use int16 range
        if (v > 32767) v = 32767;
        if (v < -32768) v = -32768;
        out[i] = (int16_t)v;
    }
}

static int16_t workbuf[FRAME_LEN];

int main(void) {
    HAL_Init();
    // SystemClock_Config() will be generated by CubeMX
    // MX_GPIO_Init(); MX_DMA_Init(); MX_ADC1_Init(); MX_TIM2_Init(); MX_SPI1_Init(); ...
    HAL_Delay(100);

    // OLED
    ssd1306_init(&hspi1);
    ssd1306_clear();
    ui_draw_header();
    ssd1306_draw_text_5x7(0, 12, "Init ADC/DMA...");
    ssd1306_update();

    // Start sampling
    start_sampling();
    ui_show_msg("Listening...");

    while (1) {
        if (g_half_ready) {
            g_half_ready = 0;
            convert_u12_to_i16(&adc_dma_buf[0], workbuf, FRAME_LEN);
            tuner_estimate_t est;
            if (tuner_estimate_frame(workbuf, FRAME_LEN, &est)) {
                float f_target = kTunings[g_sel_tuning].strings[g_sel_string].freq;
                ssd1306_clear();
                ui_draw_header();
                ui_draw_meas(est.freq_hz, f_target);
                ssd1306_update();
            }
        }
        if (g_full_ready) {
            g_full_ready = 0;
            convert_u12_to_i16(&adc_dma_buf[FRAME_LEN], workbuf, FRAME_LEN);
            tuner_estimate_t est;
            if (tuner_estimate_frame(workbuf, FRAME_LEN, &est)) {
                float f_target = kTunings[g_sel_tuning].strings[g_sel_string].freq;
                ssd1306_clear();
                ui_draw_header();
                ui_draw_meas(est.freq_hz, f_target);
                ssd1306_update();
            }
        }
        __WFI();
    }
}
